黑白版crossme解谜方法与实现


最基础的元素称为点Point，对应着游戏中的一个一个方格子。
Point的值为3种：未知（？），有（A），无（.）。游戏开始时，所有的Point都是？。

同一行/列中的所有点组成了线Line。Line可能是行也可能是列。
Line拥有参数，即侧边上那组数字。参数有顺序，对列的参数来说是从上到下，对行的参数来说是从左到右。

所有的点构成的矩阵称为盘面Board。Point直接和Board建立了连接，而Line是Point的一种组织方式。Line也挂在Board下。

游戏整体称为Game。


当Line被给定了参数的时候，其可能的结果是有限的。
参数可能有3种情况：
a）参数为{0}
   此时Line中所有Point的值都是无。
b）参数恰好能填充满Line，例如10位Line的参数是{10}，10位Line的参数是{4,5}等情况。
   此时直接顺序按参数填充即可，Line中所有Point的值都能够确定为有或无。
c）其他情况。此时参数不能够填充满Line。
   在此状况下，可以根据参数计算出全部的可能结果并保存。

这里以10位Line对应参数{2,1,3}来举例讨论如何得到全部结果。

图例
?  未知值的Point
+  确定有的Point
_  可能无的Point（占位用，实质上相当于？）
*  可能有的Point（占位用，实质上相当于？
.  确定无的Point

开始分析的时候，Line总是全空的
[??????????]
------------
 0123456789

将2-1-3做最紧密的压缩
++.+.+++
总长度为8
因此，第一个元素的位置只能是0，1，2。当第一个元素放到了3的时候，即使按最紧密的顺序，后续也会溢出。

A0: [++_*_***??]
A1: [.++_*_***?]
A2: [..++_*_***]
    ------------
     0123456789

可以看到，A2其实已经没有任何调整空间，完全确定了。而A0和A1还可以继续调整
A2: [..++.+.+++]
    ------------
     0123456789

重复以上步骤，将1-3做最紧密压缩
+.+++
总长度为5

因此，在A0后续，可以将第二个元素放到3，4，5

A0-3: [++.+_***??]
A0-4: [++..+_***?]
A0-5: [++...+_***]
      ------------
       0123456789

同样做法使用在A1上，第二个元素可以放到4，5

A1-4: [.++.+_***?]
A1-5: [.++..+_***]
      ------------
       0123456789

可以看到A0-5和A1-5也已经确定了

继续对A0-3、A0-4、A1-4重复以上动作，可以得到10位Line在参数「2，1，3」下的全部可能结果

A0-3-5: [++.+.+++..]
A0-3-6: [++.+..+++.]
A0-3-7: [++.+...+++]
A0-4-6: [++..+.+++.]
A0-4-7: [++..+..+++]
A0-5-7: [++...+.+++]
A1-4-6: [.++.+.+++.]
A1-4-7: [.++.+..+++]
A1-5-7: [.++..+.+++]
A2-5-7: [..++.+.+++]
        ------------
         0123456789

全部的可能结果放到一起汇总，如果同一位置上的Point在所有的可能结果中都是一致的，那说明这个Point的状态也是确定的。

例如分析10位Line参数{8}，得到
A0: [++++++++..]
A1: [.++++++++.]
A2: [..++++++++]
    ------------
     0123456789

汇总得到
    [??++++++??]
    ------------
     0123456789

即Line的2，3，4，5，6，7位Point确定是有


当某种改变触发了一个Point的状态改变时，包含有这个Point的两个Line都要受到影响。

当这个Point的值变为确定时，相关联的两个Line的可能性会发生变化，与这个确定值相冲突的可能性将被删除，
此时将余下的可能性再次综合，有可能会确定该Line上其他未确定Point。

以上面提到的10位Line参数{8}为例
在之前的基础上，1位的Point设定为有
则发生冲突的A2可能性要被删除
重新汇总余下的可能性

    [?+++++++?.]
    ------------
     0123456789
              ^
9位确定为无



在实际的迭代过程中，一般是行列联动，即行的分析改动了Point，然后做对应的列的分析，以此类推。



存在一种可能，即所有的行和列都已经分析过了，但是没有任何新的Point发生改变。此时无法通过上述方法继续进行下去。

这时需要通过人工分支的手段来处理。

在Game层，复制一份Board出来。此时拥有两个完全相同的Board。选取一个当前未知点，在1# Board中将其设置为有，在2# Board
中将其设置为无

基于上面的改变，分别应用之前的方法继续分析这两个Board。

如果发现明显的逻辑错误，则将相关的Board删除

如果走到某一步又一次出现了此问题，则再重复上面的做法。




